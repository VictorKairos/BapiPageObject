{"version":3,"sources":["chunk-stream.ts"],"names":[],"mappings":";AAAA,iCAAkC;AAIlC,iBAAkB,SAAQ,MAAM,CAAC,MAAM;IAQnC;QACI,KAAK,EAAE,CAAC;QA4EZ,gBAAW,GAAG,IAAI,CAAC,GAAG,CAAC;QA1EnB,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;QACnB,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;QAEnB,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;QACjB,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QAErB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;IACzB,CAAC;IAED,KAAK,CAAC,IAAI;QACN,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;IACvC,CAAC;IAED,MAAM,CAAC,IAAI,EAAE,QAAQ,EAAE,EAAE;QAErB,IAAI,IAAI,CAAC,QAAQ,KAAK,KAAK,EAAE;YACzB,EAAE,CAAC,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC,CAAC;YACrC,OAAO,KAAK,CAAC;SAChB;QAED,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACzB,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,MAAM,CAAC;QAE9B,YAAY,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;QAEpC,wCAAwC;QACxC,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;YACzC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;SACvB;QAED,EAAE,EAAE,CAAC;IACT,CAAC;IAED,IAAI,CAAC,MAAM,EAAE,QAAS;QAElB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;YACb,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC;YACxB,SAAS,EAAE,MAAM,GAAG,CAAC;YACrB,IAAI,EAAE,QAAQ;SACjB,CAAC,CAAC;QAEH,YAAY,CAAC,GAAG,EAAE;YAEd,IAAI,CAAC,QAAQ,EAAE,CAAC;YAEhB,6DAA6D;YAC7D,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;gBACxC,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;gBAErB,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;aACtB;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAED,GAAG,CAAC,IAAK;QAEL,IAAI,IAAI,EAAE;YACN,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;SACpB;QAED,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;QAEtB,oBAAoB;QACpB,IAAI,CAAC,IAAI,CAAC,QAAQ;YAAE,OAAO;QAE3B,wBAAwB;QACxB,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;YAC5B,IAAI,CAAC,IAAI,EAAE,CAAC;SACf;aAAM;YACH,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACzB,YAAY,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;SACvC;IACL,CAAC;IAID,OAAO;QAEH,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAChB,OAAO;SACV;QAED,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;QACtB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QAErB,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IACvB,CAAC;IAEO,IAAI;QAER,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;YACxB,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,KAAK,CAAC,wDAAwD,CAAC,CAAC,CAAC;SAC3F;QAED,IAAI,CAAC,OAAO,EAAE,CAAC;IACnB,CAAC;IAEO,QAAQ;QAEZ,IAAI,GAAW,EAAE,IAAY,EAAE,GAAW,EAAE,GAAW,EAAE,KAAa,EAAE,IAAS,CAAC;QAElF,iDAAiD;QACjD,OAAO,IAAI,CAAC,SAAS,GAAG,CAAC,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;YAEhE,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAEtB,0CAA0C;YAC1C,IAAI,IAAI,CAAC,SAAS,EAAE;gBAEhB,2DAA2D;gBAC3D,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,UAAU;gBAE/B,0CAA0C;gBAC1C,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAEvB,qCAAqC;gBACrC,IAAI,GAAG,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE;oBAE1B,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,MAAM,CAAC;oBAC9B,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;oBAE1C,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;iBAEnD;qBAAM;oBACH,oDAAoD;oBACpD,IAAI,CAAC,SAAS,IAAI,GAAG,CAAC,MAAM,CAAC;oBAC7B,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC,CAAC,SAAS;oBAEhC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;iBAC7B;aACJ;iBAAM,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,MAAM,EAAE;gBACtC,mCAAmC;gBAEnC,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,UAAU;gBAE/B,GAAG,GAAG,CAAC,CAAC;gBACR,KAAK,GAAG,CAAC,CAAC;gBACV,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBAEjC,6BAA6B;gBAC7B,OAAO,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE;oBACtB,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC,CAAC;oBAC7B,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC,CAAC;oBAE9C,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;oBAC5B,GAAG,IAAI,GAAG,CAAC;oBAEX,yDAAyD;oBACzD,IAAI,GAAG,KAAK,GAAG,CAAC,MAAM,EAAE;wBACpB,IAAI,CAAC,QAAQ,CAAC,EAAE,KAAK,CAAC,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;qBAC3C;iBACJ;gBAED,0BAA0B;gBAC1B,IAAI,KAAK,GAAG,CAAC,EAAE;oBACX,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;iBAClC;gBAED,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,MAAM,CAAC;gBAE9B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;aAE9B;iBAAM;gBACH,qDAAqD;gBACrD,8BAA8B;gBAC9B,MAAM;aACT;SACJ;QAED,IAAI,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;YACxE,IAAI,CAAC,IAAI,EAAE,CAAC;SACf;IACL,CAAC;CACJ;AA3LD,iBAAS,WAAW,CAAC","file":"chunk-stream.js","sourcesContent":["import stream = require(\"stream\");\r\n\r\nexport = ChunkStream;\r\n\r\nclass ChunkStream extends stream.Duplex {\r\n\r\n    private _buffers: Buffer[];\r\n    private _buffered: number;\r\n    private _reads: any[];\r\n    private _paused: boolean;\r\n    private _encoding: string;\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        this._buffers = [];\r\n        this._buffered = 0;\r\n\r\n        this._reads = [];\r\n        this._paused = false;\r\n\r\n        this.writable = true;\r\n    }\r\n\r\n    _read(size) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    _write(data, encoding, cb) {\r\n\r\n        if (this.writable === false) {\r\n            cb(new Error(\"Stream not writable\"));\r\n            return false;\r\n        }\r\n\r\n        this._buffers.push(data);\r\n        this._buffered += data.length;\r\n\r\n        setImmediate(() => this._process());\r\n\r\n        // ok if there are no more read requests\r\n        if (this._reads && this._reads.length === 0) {\r\n            this._paused = true;\r\n        }\r\n\r\n        cb();\r\n    }\r\n\r\n    read(length, callback?) {\r\n\r\n        this._reads.push({\r\n            length: Math.abs(length),  // if length < 0 then at most this length\r\n            allowLess: length < 0,\r\n            func: callback\r\n        });\r\n\r\n        setImmediate(() => {\r\n\r\n            this._process();\r\n\r\n            // its paused and there is not enought data then ask for more\r\n            if (this._paused && this._reads.length > 0) {\r\n                this._paused = false;\r\n\r\n                this.emit(\"drain\");\r\n            }\r\n        });\r\n    }\r\n\r\n    end(data?): void {\r\n\r\n        if (data) {\r\n            this.write(data);\r\n        }\r\n\r\n        this.writable = false;\r\n\r\n        // already destroyed\r\n        if (!this._buffers) return;\r\n\r\n        // enqueue or handle end\r\n        if (this._buffers.length === 0) {\r\n            this._end();\r\n        } else {\r\n            this._buffers.push(null);\r\n            setImmediate(() => this._process());\r\n        }\r\n    }\r\n\r\n    destroySoon = this.end;\r\n\r\n    destroy() {\r\n\r\n        if (!this._buffers) {\r\n            return;\r\n        }\r\n\r\n        this.writable = false;\r\n        this._reads = null;\r\n        this._buffers = null;\r\n\r\n        this.emit(\"close\");\r\n    }\r\n\r\n    private _end() {\r\n\r\n        if (this._reads.length > 0) {\r\n            this.emit(\"error\", new Error(\"There are some read requests waitng on finished stream\"));\r\n        }\r\n\r\n        this.destroy();\r\n    }\r\n\r\n    private _process() {\r\n\r\n        let buf: Buffer, data: Buffer, len: number, pos: number, count: number, read: any;\r\n\r\n        // as long as there is any data and read requests\r\n        while (this._buffered > 0 && this._reads && this._reads.length > 0) {\r\n\r\n            read = this._reads[0];\r\n\r\n            // read any data (but no more than length)\r\n            if (read.allowLess) {\r\n\r\n                // ok there is any data so that we can satisfy this request\r\n                this._reads.shift(); // == read\r\n\r\n                // first we need to peek into first buffer\r\n                buf = this._buffers[0];\r\n\r\n                // ok there is more data than we need\r\n                if (buf.length > read.length) {\r\n\r\n                    this._buffered -= read.length;\r\n                    this._buffers[0] = buf.slice(read.length);\r\n\r\n                    read.func.call(this, buf.slice(0, read.length));\r\n\r\n                } else {\r\n                    // ok this is less than maximum length so use it all\r\n                    this._buffered -= buf.length;\r\n                    this._buffers.shift(); // == buf\r\n\r\n                    read.func.call(this, buf);\r\n                }\r\n            } else if (this._buffered >= read.length) {\r\n                // ok we can meet some expectations\r\n\r\n                this._reads.shift(); // == read\r\n\r\n                pos = 0;\r\n                count = 0;\r\n                data = Buffer.alloc(read.length);\r\n\r\n                // create buffer for all data\r\n                while (pos < read.length) {\r\n                    buf = this._buffers[count++];\r\n                    len = Math.min(buf.length, read.length - pos);\r\n\r\n                    buf.copy(data, pos, 0, len);\r\n                    pos += len;\r\n\r\n                    // last buffer wasn't used all so just slice it and leave\r\n                    if (len !== buf.length) {\r\n                        this._buffers[--count] = buf.slice(len);\r\n                    }\r\n                }\r\n\r\n                // remove all used buffers\r\n                if (count > 0) {\r\n                    this._buffers.splice(0, count);\r\n                }\r\n\r\n                this._buffered -= read.length;\r\n\r\n                read.func.call(this, data);\r\n\r\n            } else {\r\n                // not enought data to satisfy first request in queue\r\n                // so we need to wait for more\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (this._buffers && this._buffers.length > 0 && this._buffers[0] === null) {\r\n            this._end();\r\n        }\r\n    }\r\n}\r\n"]}